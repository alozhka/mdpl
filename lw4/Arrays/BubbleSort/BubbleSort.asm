.set ARR_SIZE=10
; для удобства
.def temp=r16

; В сегменте данных выделим массив типа BYTE
.dseg
arr: .BYTE ARR_SIZE

.cseg
; выделим массив перед основной программой, чтобы не искать постоянно
; адрес его начала
src: .db 0x8E, 0x6B, 0xAE, 0x60, 0x7F, 0x69, 0xD8, 0x2B, 0x02, 0x15

reset:
	rjmp main
main:
	ldi ZH,High(src*2) ;загрузка адреса 0-го
	ldi ZL,Low(src*2) ;элемента в рег. пару Z
	ldi YH,High(arr) ;загрузка адреса 0-го
	ldi YL,Low(arr) ;элемента в рег. пару Y
	ldi r18, ARR_SIZE ; загрузка размера массива в счётчик элементов массива
arr_copy:
	lpm r0, Z+		; Загрузка байта по адресу Z в регистр R0 с увеличением адреса
	out OCR0A, R0	; вывод значения в регистр IO
	com r0			; побитная инверсия значения в регистре R0
	out OCR0B, r0	; вывод значения в регистр IO
	st Y+, r0		; Сохранение значения регистра R0 байта в ОЗУ по адресу Y с увеличением адреса
	subi r18, 1		; Уменьшение значения счётчика итераций
	brne arr_copy	; Условный переход пока не прошли все элементы массива

loop:
	; Ввыставляем значение на нулевой элемент
	ldi YH,High(arr)
	ldi YL,Low(arr)
rjmp loop

